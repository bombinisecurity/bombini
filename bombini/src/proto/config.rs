// This file is @generated by prost-build.
/// Configuration file for ProcMon detector
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProcMonConfig {
    /// setuid hook config.
    #[prost(message, optional, tag = "1")]
    pub setuid: ::core::option::Option<ProcHookConfig>,
    /// capset hook config.
    #[prost(message, optional, tag = "2")]
    pub capset: ::core::option::Option<ProcHookConfig>,
    /// prctl hook config.
    #[prost(message, optional, tag = "3")]
    pub prctl: ::core::option::Option<ProcHookConfig>,
    /// create_user_ns hook config.
    #[prost(message, optional, tag = "4")]
    pub create_user_ns: ::core::option::Option<ProcHookConfig>,
    /// ptrace_attach hook config.
    #[prost(message, optional, tag = "5")]
    pub ptrace_access_check: ::core::option::Option<ProcHookConfig>,
    /// setgid hook config.
    #[prost(message, optional, tag = "6")]
    pub setgid: ::core::option::Option<ProcHookConfig>,
    /// Process Filter Configuration.
    #[prost(message, optional, tag = "7")]
    pub process_filter: ::core::option::Option<ProcessFilter>,
    /// Collect IMA hashes for executed binaries.
    #[prost(bool, optional, tag = "8")]
    pub ima_hash: ::core::option::Option<bool>,
    /// GC period for PROCMON_PROC_MAP default 30 sec.
    #[prost(uint64, optional, tag = "9")]
    pub gc_period: ::core::option::Option<u64>,
}
/// ProcMon hook configuration
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProcHookConfig {
    /// Load eBPF programs
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Filter by Cred
    #[prost(message, optional, tag = "2")]
    pub cred_filter: ::core::option::Option<CredFilter>,
}
/// Filter Events using process information.
/// Filtering is based on pattern: uid AND euid AND auid AND (binary.name OR binary.prefix OR binary.path).
/// All variables in the pattern are optional. if deny_list is true filter acts as a deny list, otherwise it
/// is an allow list.
#[derive(serde::Deserialize)]
#[serde(default)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProcessFilter {
    /// List of UID's to filter.
    #[prost(uint32, repeated, tag = "1")]
    pub uid: ::prost::alloc::vec::Vec<u32>,
    /// List of EUID's to filter.
    #[prost(uint32, repeated, tag = "2")]
    pub euid: ::prost::alloc::vec::Vec<u32>,
    /// List of AUID's (login uid) to filter.
    #[prost(uint32, repeated, tag = "3")]
    pub auid: ::prost::alloc::vec::Vec<u32>,
    /// Binary filter args
    #[prost(message, optional, tag = "4")]
    pub binary: ::core::option::Option<PathFilter>,
    /// if true acts like deny list
    #[prost(bool, tag = "5")]
    pub deny_list: bool,
}
/// Filter Events using Cred information. Pattern uid_filter || cap_filter.
#[derive(serde::Deserialize)]
#[serde(default)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CredFilter {
    /// Filter by uids (euid, TODO: uid, fsuid).
    #[prost(message, optional, tag = "1")]
    pub uid_filter: ::core::option::Option<UidFilter>,
    /// Filter by  caps (effective, TODO: permitted, inheritable).
    #[prost(message, optional, tag = "2")]
    pub cap_filter: ::core::option::Option<CapFilter>,
    /// Filter by gids (euid, TODO: gid, fsgid).
    #[prost(message, optional, tag = "3")]
    pub gid_filter: ::core::option::Option<GidFilter>,
}
/// Capabilities filter
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CapFilter {
    /// List of effective Capabilities. Special name ANY means if any cap is in effective cap set.
    #[prost(string, repeated, tag = "1")]
    pub effective: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// if true acts like deny list
    #[prost(bool, optional, tag = "2")]
    pub deny_list: ::core::option::Option<bool>,
}
/// UID filter
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UidFilter {
    /// effective UID
    #[prost(uint32, repeated, tag = "1")]
    pub euid: ::prost::alloc::vec::Vec<u32>,
}
/// GID filter
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GidFilter {
    /// effective GID
    #[prost(uint32, repeated, tag = "1")]
    pub egid: ::prost::alloc::vec::Vec<u32>,
}
/// Path filtering args
#[derive(serde::Deserialize)]
#[serde(default)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PathFilter {
    /// List of executables names to filter.
    #[prost(string, repeated, tag = "1")]
    pub name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of full executable paths to filter.
    #[prost(string, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of executable path prefixes to filter.
    #[prost(string, repeated, tag = "3")]
    pub prefix: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Configuration file for FileMon detector.
#[derive(serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FileMonConfig {
    /// security_file_open config.
    #[prost(message, optional, tag = "1")]
    pub file_open: ::core::option::Option<HookConfig>,
    /// security_path_truncate config.
    #[prost(message, optional, tag = "2")]
    pub path_truncate: ::core::option::Option<HookConfig>,
    /// security_path_unlink config.
    #[prost(message, optional, tag = "3")]
    pub path_unlink: ::core::option::Option<HookConfig>,
    /// security_path_symlink config.
    #[prost(message, optional, tag = "4")]
    pub path_symlink: ::core::option::Option<HookConfig>,
    /// security_path_chmod config.
    #[prost(message, optional, tag = "5")]
    pub path_chmod: ::core::option::Option<HookConfig>,
    /// security_path_chown config.
    #[prost(message, optional, tag = "6")]
    pub path_chown: ::core::option::Option<HookConfig>,
    /// security_sb_mount config.
    #[prost(message, optional, tag = "7")]
    pub sb_mount: ::core::option::Option<HookConfig>,
    /// security_mmap_file config.
    #[prost(message, optional, tag = "8")]
    pub mmap_file: ::core::option::Option<HookConfig>,
    /// security_file_ioctl config.
    #[prost(message, optional, tag = "9")]
    pub file_ioctl: ::core::option::Option<HookConfig>,
}
/// Configuration file for NetMon detector.
#[derive(serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct NetMonConfig {
    /// Ingress traffic connections
    #[prost(message, optional, tag = "1")]
    pub ingress: ::core::option::Option<HookConfig>,
    /// Egress traffic connections
    #[prost(message, optional, tag = "2")]
    pub egress: ::core::option::Option<HookConfig>,
}
/// Configuration file for GTFOBinsDetector.
#[derive(serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GtfoBinsConfig {
    /// Block execution of GTFOBins binaries.
    #[prost(bool, tag = "1")]
    pub enforce: bool,
    /// GTFOBins executables names.
    #[prost(string, repeated, tag = "2")]
    pub gtfobins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Rule definition. Scope and event predicates are used as logical conjunction.
#[derive(serde::Deserialize)]
#[serde(default)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rule {
    /// Name of the rule.
    #[prost(string, tag = "1")]
    #[serde(rename = "rule")]
    pub name: ::prost::alloc::string::String,
    /// Logical predicate describes scope this rule will be applied, e.g. process, container.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub scope: ::prost::alloc::string::String,
    /// Logical predicate for describes event rule will be applied
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub event: ::prost::alloc::string::String,
}
/// Hook or group of hooks configuration
#[derive(serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct HookConfig {
    /// Load eBPF programs
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Filtering rules
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
}
